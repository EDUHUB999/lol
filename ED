-- โหลด Fluent UI Library และ Addons
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

-- สร้าง Window
_G.Window = Fluent:CreateWindow({
    Title = "EDU HUB : Stand Upright : Rebooted",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Amethyst",
    MinimizeKey = Enum.KeyCode.RightControl
})

-- สร้าง Tabs
_G.Tabs = {
    FarmingQuests = _G.Window:AddTab({ Title = "Farming & Quests", Icon = "" }),
    AutoFarmLevels = _G.Window:AddTab({ Title = "Auto Farm All Levels", Icon = "" }),
    BossFarm = _G.Window:AddTab({ Title = "Boss Farm", Icon = "" }),
    StandFarm = _G.Window:AddTab({ Title = "Stand Farm", Icon = "" }),
    AutoBuy = _G.Window:AddTab({ Title = "Auto Buy Item", Icon = "" }),
    DungeonFarm = _G.Window:AddTab({ Title = "Dungeon Farm", Icon = "" }),
    ItemFarm = _G.Window:AddTab({ Title = "Item Farm", Icon = "" }),
    Settings = _G.Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options

local LocalPlayer = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
_G.BeginFarm = false
_G.debugMode = false

_G.Teleport = function(part, cframe)
    if part and part:IsA("BasePart") then
        pcall(function()
            part.CFrame = cframe
            part.Velocity = Vector3.new(0, 0, 0)
        end)
    end
end

_G.waitForCharacter = function()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart", 5)
    local humanoid = char:WaitForChild("Humanoid", 5)
    if not hrp or not humanoid then
        return nil
    end
    return char
end

local char = _G.waitForCharacter()
if not char then return end
local hrp = char.HumanoidRootPart
local originalPosition = hrp.CFrame

_G.Teleport(hrp, CFrame.new(-727.006897, 67.0773239, -939.000366, 0.422592998, -0, -0.906319618, 0, 1, -0, 0.906319618, 0, 0.422592998))
task.wait(0.6)
_G.Teleport(hrp, CFrame.new(28080.0684, 49.5559769, -237.245163, -0.866007447, 0.00292324182, -0.500022888, 0, 0.999982893, 0.00584611483, 0.500031412, 0.00506277755, -0.865992606))
task.wait(0.6)
_G.Teleport(hrp, CFrame.new(11927.1, -3.28935, -4488.59))
task.wait(0.6)
_G.Teleport(hrp, CFrame.new(-5234.27051, -449.936951, -3766.07373, 0.958408535, 1.30176289e-07, 0.285399795, 0.000306290051, 0.999999404, -0.0010290168, -0.285399646, 0.00107363367, 0.958407998))
task.wait(0.6)
_G.Teleport(hrp, originalPosition)

_G.Disc = 8.5
_G.Disc3 = 1
local bodyPosition = nil
local bodyGyro = nil
_G.isUsingAllSkills = false

_G.createBodyControls = function(hrp)
    if not bodyPosition then
        bodyPosition = Instance.new("BodyPosition")
        bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bodyPosition.P = 10000
        bodyPosition.D = 1000
        bodyPosition.Parent = hrp
    end
    if not bodyGyro then
        bodyGyro = Instance.new("BodyGyro")
        bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bodyGyro.P = 5000
        bodyGyro.D = 500
        bodyGyro.Parent = hrp
    end
end

_G.fireServerSafe = function(remote, arg)
    local success = pcall(function()
        if arg ~= nil then
            remote:FireServer(arg)
        else
            remote:FireServer()
        end
    end)
    return success
end

_G.useAllSkills = function(char)
    if char and char:FindFirstChild("StandEvents") then
        for _, event in pairs(char.StandEvents:GetChildren()) do
            if not table.find({"Block", "Quote", "Pose", "Summon", "Heal", "Jump", "TogglePilot"}, event.Name) then
                _G.fireServerSafe(event, true)
                task.wait(0.05)
            end
        end
    end
end

_G.useSelectedSkills = function(char, selectedSkills)
    if char and char:FindFirstChild("StandEvents") and selectedSkills then
        for skill, enabled in pairs(selectedSkills) do
            if enabled then
                local skillEvent = char.StandEvents:FindFirstChild(skill)
                if skillEvent then
                    _G.fireServerSafe(skillEvent, true)
                    task.wait(0.05)
                end
            end
        end
    end
end

_G.getPlayerSkills = function()
    local char = _G.waitForCharacter()
    local skillList = {"None"}
    if char and char:FindFirstChild("StandEvents") then
        for _, event in pairs(char.StandEvents:GetChildren()) do
            if not table.find({"Block", "Quote", "Pose", "Summon", "Heal", "Jump", "TogglePilot"}, event.Name) then
                table.insert(skillList, event.Name)
            end
        end
    end
    return skillList
end

_G.findNearestMonster = function(monsterName)
    local closestMonster = nil
    local shortestDistance = math.huge
    for _, mob in pairs(Workspace.Living:GetChildren()) do
        if mob.Name == monsterName and mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 then
            local distance = (LocalPlayer.Character.HumanoidRootPart.Position - mob.PrimaryPart.Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                closestMonster = mob
            end
        end
    end
    return closestMonster
end

_G.lastTeleportTime = 0
_G.teleportToTarget = function(target)
    if target and target.PrimaryPart then
        local char = _G.waitForCharacter()
        if not char then return end
        local hrp = char.HumanoidRootPart
        
        local targetPos = target.PrimaryPart.Position
        local hoverPos = targetPos + Vector3.new(0, _G.Disc, _G.Disc3)
        local targetCFrame = CFrame.lookAt(hoverPos, targetPos)
        
        _G.createBodyControls(hrp)
        bodyPosition.Position = hoverPos
        bodyGyro.CFrame = targetCFrame
        
        local currentTime = tick()
        local distance = (hrp.Position - hoverPos).Magnitude
        if distance > 5 and currentTime - _G.lastTeleportTime > 0.5 then
            _G.Teleport(hrp, targetCFrame)
            char.Humanoid.Sit = true
            _G.lastTeleportTime = currentTime
        end
    end
end

-- Tab: Farming & Quests
_G.isFarming = false
_G.selectedQuest = "Bad Gi [Lvl. 1+]"
local connection
_G.lastMonsterCount = 0
_G.monsterRespawnDistance = 30

local questList = {
    "Bad Gi [Lvl. 1+]", "Scary Monster [Lvl. 10+]", "Giorno Giovanna [Lvl. 20+]", "Rker Dummy [Lvl. 30+]",
    "Yoshikage Kira [Lvl. 40+]", "Dio Over Heaven [Lvl. 50+]", "Angelo [Lvl. 75+]", "Alien [Lvl. 100+]",
    "Jotaro Part 4 [Lvl. 125+]", "Kakyoin [Lvl. 150+]", "Sewer Vampire [Lvl. 200+]", "Pillerman [Lvl. 275+]"
}

local questData = {
    ["Bad Gi [Lvl. 1+]"] = {monster = "Bad Gi", npc = "Giorno"},
    ["Scary Monster [Lvl. 10+]"] = {monster = "Scary Monster", npc = "Scared Noob"},
    ["Giorno Giovanna [Lvl. 20+]"] = {monster = "Giorno Giovanna", npc = "Koichi"},
    ["Rker Dummy [Lvl. 30+]"] = {monster = "Rker Dummy", npc = "aLLmemester"},
    ["Yoshikage Kira [Lvl. 40+]"] = {monster = "Yoshikage Kira", npc = "Okayasu"},
    ["Dio Over Heaven [Lvl. 50+]"] = {monster = "Dio Over Heaven", npc = "Joseph Joestar"},
    ["Angelo [Lvl. 75+]"] = {monster = "Angelo", npc = "Josuke"},
    ["Alien [Lvl. 100+]"] = {monster = "Alien", npc = "Rohan"},
    ["Jotaro Part 4 [Lvl. 125+]"] = {monster = "Jotaro Part 4", npc = "DIO"},
    ["Kakyoin [Lvl. 150+]"] = {monster = "Kakyoin", npc = "Muhammed Avdol"},
    ["Sewer Vampire [Lvl. 200+]"] = {monster = "Sewer Vampire", npc = "Zeppeli"},
    ["Pillerman [Lvl. 275+]"] = {monster = "Pillerman", npc = "Young Joseph"}
}

_G.countMonsters = function(monsterName)
    local count = 0
    for _, mob in pairs(Workspace.Living:GetChildren()) do
        if mob.Name == monsterName and mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 then
            count = count + 1
        end
    end
    return count
end

_G.startFarming = function()
    if connection then connection:Disconnect() end
    connection = RunService.Heartbeat:Connect(function()
        if not _G.isFarming then
            connection:Disconnect()
            if bodyPosition then bodyPosition:Destroy() bodyPosition = nil end
            if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
            local char = _G.waitForCharacter()
            if char then char.Humanoid.Sit = false end
            return
        end
        
        local quest = questData[_G.selectedQuest]
        local target = _G.findNearestMonster(quest.monster)
        local currentMonsterCount = _G.countMonsters(quest.monster)
        
        if target then
            _G.teleportToTarget(target)
            local npc = Workspace.Map.NPCs:FindFirstChild(quest.npc)
            if npc then
                _G.fireServerSafe(npc.Done)
                _G.fireServerSafe(npc.QuestDone)
            end
            local char = _G.waitForCharacter()
            if char then
                if char:FindFirstChild("Aura") and not char.Aura.Value then
                    _G.fireServerSafe(char.StandEvents.Summon)
                end
                if char:FindFirstChild("StandEvents") and not LocalPlayer.PlayerGui.CDgui.fortnite:FindFirstChild("Punch") then
                    _G.fireServerSafe(char.StandEvents.M1)
                end
                local selectedSkills = Options.SelectedSkills and Options.SelectedSkills.Value or {}
                if next(selectedSkills) then
                    _G.useSelectedSkills(char, selectedSkills)
                elseif _G.isUsingAllSkills then
                    _G.useAllSkills(char)
                end
            end
            _G.lastMonsterCount = currentMonsterCount
        else
            if _G.lastMonsterCount > 0 and currentMonsterCount == 0 then
                if bodyPosition then bodyPosition:Destroy() bodyPosition = nil end
                if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
                local char = _G.waitForCharacter()
                if char then
                    char.Humanoid.Sit = false
                    local resetPosition = char.HumanoidRootPart.CFrame + Vector3.new(0, 3, _G.monsterRespawnDistance)
                    _G.Teleport(char.HumanoidRootPart, resetPosition)
                end
                task.wait(2)
            elseif currentMonsterCount > 0 then
                target = _G.findNearestMonster(quest.monster)
                if target then
                    _G.teleportToTarget(target)
                end
            end
        end
    end)
end

_G.Tabs.FarmingQuests:AddToggle("AutoFarmQuests", {Title = "Auto Farm & Quests", Description = "Toggle auto farming and quests", Default = false})
Options.AutoFarmQuests:OnChanged(function()
    _G.isFarming = Options.AutoFarmQuests.Value
    if _G.isFarming then
        task.spawn(_G.startFarming)
    else
        if bodyPosition then bodyPosition:Destroy() bodyPosition = nil end
        if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
        local char = _G.waitForCharacter()
        if char then char.Humanoid.Sit = false end
    end
end)

_G.Tabs.FarmingQuests:AddDropdown("SelectQuest", {Title = "Select Quest/Monster", Values = questList, Default = 1})
Options.SelectQuest:OnChanged(function()
    _G.selectedQuest = Options.SelectQuest.Value
end)

_G.Tabs.FarmingQuests:AddSlider("YOffset", {Title = "Y Offset", Description = "Adjust hover height", Default = 8.5, Min = -30, Max = 30, Rounding = 1})
Options.YOffset:OnChanged(function(Value)
    _G.Disc = Value
end)

_G.Tabs.FarmingQuests:AddSlider("ZOffset", {Title = "Z Offset", Description = "Adjust forward/backward distance", Default = 0, Min = -30, Max = 30, Rounding = 1})
Options.ZOffset:OnChanged(function(Value)
    _G.Disc3 = Value
end)

_G.Tabs.FarmingQuests:AddButton({Title = "Refresh Character", Description = "Reset character state", Callback = function()
    local char = _G.waitForCharacter()
    if char then
        if bodyPosition then bodyPosition:Destroy() bodyPosition = nil end
        if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
        char.Humanoid.Sit = false
    end
end})

-- Tab: Auto Farm All Levels
_G.isLevelFarming = false
local levelConnection

local MonSettings = {
    ["Bad Gi [Lvl. 1+]"] = {"Bad Gi", "Giorno"},
    ["Scary Monster [Lvl. 10+]"] = {"Scary Monster", "Scared Noob"},
    ["Giorno Giovanna [Lvl. 20+]"] = {"Giorno Giovanna", "Koichi"},
    ["Rker Dummy [Lvl. 30+]"] = {"Rker Dummy", "aLLmemester"},
    ["Yoshikage Kira [Lvl. 40+]"] = {"Yoshikage Kira", "Okayasu"},
    ["Dio Over Heaven [Lvl. 50+]"] = {"Dio Over Heaven", "Joseph Joestar"},
    ["Angelo [Lvl. 75+]"] = {"Angelo", "Josuke"},
    ["Alien [Lvl. 100+]"] = {"Alien", "Rohan"},
    ["Jotaro Part 4 [Lvl. 125+]"] = {"Jotaro Part 4", "DIO"},
    ["Kakyoin [Lvl. 150+]"] = {"Kakyoin", "Muhammed Avdol"},
    ["Sewer Vampire [Lvl. 200+]"] = {"Sewer Vampire", "Zeppeli"},
    ["Pillerman [Lvl. 275+]"] = {"Pillerman", "Young Joseph"}
}

local levelMap = {
    {minLevel = 1, maxLevel = 10, name = "Bad Gi [Lvl. 1+]"},
    {minLevel = 11, maxLevel = 20, name = "Scary Monster [Lvl. 10+]"},
    {minLevel = 21, maxLevel = 30, name = "Giorno Giovanna [Lvl. 20+]"},
    {minLevel = 31, maxLevel = 40, name = "Rker Dummy [Lvl. 30+]"},
    {minLevel = 41, maxLevel = 50, name = "Yoshikage Kira [Lvl. 40+]"},
    {minLevel = 51, maxLevel = 75, name = "Dio Over Heaven [Lvl. 50+]"},
    {minLevel = 76, maxLevel = 100, name = "Angelo [Lvl. 75+]"},
    {minLevel = 101, maxLevel = 125, name = "Alien [Lvl. 100+]"},
    {minLevel = 126, maxLevel = 150, name = "Jotaro Part 4 [Lvl. 125+]"},
    {minLevel = 151, maxLevel = 200, name = "Kakyoin [Lvl. 150+]"},
    {minLevel = 201, maxLevel = 275, name = "Sewer Vampire [Lvl. 200+]"},
    {minLevel = 276, maxLevel = math.huge, name = "Pillerman [Lvl. 275+]"}
}

_G.findMultipleMonsters = function(monsterName, maxTargets)
    local targets = {}
    for _, mob in pairs(Workspace.Living:GetChildren()) do
        if mob.Name == monsterName and mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 then
            table.insert(targets, mob)
            if #targets >= maxTargets then break end
        end
    end
    return targets
end

_G.startLevelFarming = function()
    if levelConnection then levelConnection:Disconnect() end
    local lastSwitchTime = 0
    local currentTargetIndex = 1
    local switchInterval = 0.2
    
    levelConnection = RunService.Heartbeat:Connect(function()
        if not _G.isLevelFarming then
            levelConnection:Disconnect()
            if bodyPosition then bodyPosition:Destroy() bodyPosition = nil end
            if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
            local char = _G.waitForCharacter()
            if char then char.Humanoid.Sit = false end
            return
        end
        
        local char = _G.waitForCharacter()
        if not char then return end
        
        local level = LocalPlayer.Data.Level.Value or 1
        local matchedSetting = nil
        for _, setting in ipairs(levelMap) do
            if level >= setting.minLevel and level <= setting.maxLevel then
                matchedSetting = MonSettings[setting.name]
                break
            end
        end
        
        if matchedSetting then
            local targets = _G.findMultipleMonsters(matchedSetting[1], 5)
            if #targets > 0 then
                local currentTime = tick()
                if currentTime - lastSwitchTime >= switchInterval then
                    currentTargetIndex = (currentTargetIndex % #targets) + 1
                    lastSwitchTime = currentTime
                end
                
                local target = targets[currentTargetIndex]
                if target then
                    _G.teleportToTarget(target)
                    local npc = Workspace.Map.NPCs:FindFirstChild(matchedSetting[2])
                    if npc then
                        _G.fireServerSafe(npc.Done)
                        _G.fireServerSafe(npc.QuestDone)
                    end
                    if char:FindFirstChild("Aura") and not char.Aura.Value then
                        _G.fireServerSafe(char.StandEvents.Summon)
                    end
                    if char:FindFirstChild("StandEvents") and not LocalPlayer.PlayerGui.CDgui.fortnite:FindFirstChild("Punch") then
                        _G.fireServerSafe(char.StandEvents.M1)
                    end
                    local selectedSkills = Options.SelectedSkills and Options.SelectedSkills.Value or {}
                    if next(selectedSkills) then
                        _G.useSelectedSkills(char, selectedSkills)
                    elseif _G.isUsingAllSkills then
                        _G.useAllSkills(char)
                    end
                end
            else
                if bodyPosition then bodyPosition:Destroy() bodyPosition = nil end
                if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
                char.Humanoid.Sit = false
                local resetPosition = char.HumanoidRootPart.CFrame + Vector3.new(0, 3, 70)
                _G.Teleport(char.HumanoidRootPart, resetPosition)
                task.wait(1)
            end
        else
            task.wait(1)
        end
    end)
end

_G.Tabs.AutoFarmLevels:AddToggle("AutoFarmLevels", {Title = "Auto Farm All Levels", Description = "Farm based on your level", Default = false})
Options.AutoFarmLevels:OnChanged(function()
    _G.isLevelFarming = Options.AutoFarmLevels.Value
    if _G.isLevelFarming then
        if _G.isFarming then
            Fluent:Notify({Title = "Error", Content = "Please disable Auto Farm & Quests first!", Duration = 5})
            _G.isLevelFarming = false
            Options.AutoFarmLevels:SetValue(false)
            return
        end
        task.spawn(_G.startLevelFarming)
    else
        if bodyPosition then bodyPosition:Destroy() bodyPosition = nil end
        if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
        local char = _G.waitForCharacter()
        if char then char.Humanoid.Sit = false end
    end
end)

-- Tab: Boss Farm
_G.isBossFarming = false
_G.selectedBosses = {}
local bossConnection
_G.previousFarmMode = nil
_G.isFightingBosses = false

local bossList = {
    "Jotaro Over Heaven", "Alternate Jotaro Part 4", "JohnnyJoestar", "Giorno Giovanna Requiem"
}

local bossSpawnLocations = {
    ["Alternate Jotaro Part 4"] = CFrame.new(1234, 567, 890)
}

_G.checkAliveBosses = function()
    local aliveBosses = {}
    for _, entity in pairs(Workspace.Living:GetChildren()) do
        if table.find(_G.selectedBosses, entity.Name) and entity:FindFirstChild("Humanoid") and entity.Humanoid.Health > 0 then
            table.insert(aliveBosses, entity)
        end
    end
    return aliveBosses
end

_G.findDungeonMinions = function()
    local minions = {}
    for _, entity in pairs(Workspace.Living:GetChildren()) do
        if entity.Name:find("Minion") and entity:FindFirstChild("Humanoid") and entity.Humanoid.Health > 0 then
            table.insert(minions, entity)
        end
    end
    return minions
end

_G.clearDungeonMinions = function()
    local char = _G.waitForCharacter()
    if not char then return false end
    local hrp = char.HumanoidRootPart
    local minions = _G.findDungeonMinions()

    if #minions == 0 then return true end

    for _, minion in pairs(minions) do
        _G.teleportToTarget(minion)
        if char:FindFirstChild("Aura") and not char.Aura.Value then
            _G.fireServerSafe(char.StandEvents.Summon)
        end
        if char:FindFirstChild("StandEvents") and not LocalPlayer.PlayerGui.CDgui.fortnite:FindFirstChild("Punch") then
            _G.fireServerSafe(char.StandEvents.M1)
        end
        local selectedSkills = Options.SelectedSkills and Options.SelectedSkills.Value or {}
        if next(selectedSkills) then
            _G.useSelectedSkills(char, selectedSkills)
        elseif _G.isUsingAllSkills then
            _G.useAllSkills(char)
        end
        task.wait(0.5)
    end
    return #_G.findDungeonMinions() == 0
end

_G.teleportToBossSpawn = function(bossName)
    local char = _G.waitForCharacter()
    if not char or not bossSpawnLocations[bossName] then return end
    _G.Teleport(char.HumanoidRootPart, bossSpawnLocations[bossName])
end

_G.startBossFarming = function()
    if bossConnection then bossConnection:Disconnect() end
    
    bossConnection = RunService.Heartbeat:Connect(function()
        if not _G.isBossFarming then
            bossConnection:Disconnect()
            if bodyPosition then bodyPosition:Destroy() bodyPosition = nil end
            if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
            local char = _G.waitForCharacter()
            if char then char.Humanoid.Sit = false end
            _G.isFightingBosses = false
            return
        end
        
        local aliveBosses = _G.checkAliveBosses()
        
        if #aliveBosses > 0 and not _G.isFightingBosses then
            if _G.isFarming then
                _G.previousFarmMode = "FarmingQuests"
                _G.isFarming = false
                Options.AutoFarmQuests:SetValue(false)
                if connection then connection:Disconnect() end
            elseif _G.isLevelFarming then
                _G.previousFarmMode = "AutoFarmLevels"
                _G.isLevelFarming = false
                Options.AutoFarmLevels:SetValue(false)
                if levelConnection then levelConnection:Disconnect() end
            end
            _G.isFightingBosses = true
            Fluent:Notify({Title = "Info", Content = "Bosses detected! Starting Boss Farm.", Duration = 3})
        end
        
        if _G.isFightingBosses and #aliveBosses > 0 then
            for _, targetBoss in pairs(aliveBosses) do
                if targetBoss.Name == "Alternate Jotaro Part 4" then
                    if _G.clearDungeonMinions() then
                        _G.teleportToTarget(targetBoss)
                    end
                else
                    _G.teleportToTarget(targetBoss)
                end
                local char = _G.waitForCharacter()
                if char then
                    if char.Humanoid.Health <= 0 then
                        Fluent:Notify({Title = "Warning", Content = "Character died! Pausing Boss Farm.", Duration = 5})
                        _G.isBossFarming = false
                        Options.AutoFarmBoss:SetValue(false)
                        return
                    end
                    if char:FindFirstChild("Aura") and not char.Aura.Value then
                        _G.fireServerSafe(char.StandEvents.Summon)
                    end
                    if char:FindFirstChild("StandEvents") and not LocalPlayer.PlayerGui.CDgui.fortnite:FindFirstChild("Punch") then
                        _G.fireServerSafe(char.StandEvents.M1)
                    end
                    local selectedSkills = Options.SelectedSkills and Options.SelectedSkills.Value or {}
                    if next(selectedSkills) then
                        _G.useSelectedSkills(char, selectedSkills)
                    elseif _G.isUsingAllSkills then
                        _G.useAllSkills(char)
                    end
                end
            end
        elseif _G.isFightingBosses and #aliveBosses == 0 then
            if bodyPosition then bodyPosition:Destroy() bodyPosition = nil end
            if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
            local char = _G.waitForCharacter()
            if char then char.Humanoid.Sit = false end
            
            if _G.previousFarmMode == "FarmingQuests" then
                _G.isFarming = true
                Options.AutoFarmQuests:SetValue(true)
                task.spawn(_G.startFarming)
                Fluent:Notify({Title = "Info", Content = "Bosses defeated! Resuming Farming & Quests.", Duration = 3})
            elseif _G.previousFarmMode == "AutoFarmLevels" then
                _G.isLevelFarming = true
                Options.AutoFarmLevels:SetValue(true)
                task.spawn(_G.startLevelFarming)
                Fluent:Notify({Title = "Info", Content = "Bosses defeated! Resuming Auto Farm All Levels.", Duration = 3})
            end
            _G.previousFarmMode = nil
            _G.isFightingBosses = false
        end
        
        if #aliveBosses == 0 and not _G.isFightingBosses then
            if table.find(_G.selectedBosses, "Alternate Jotaro Part 4") then
                _G.teleportToBossSpawn("Alternate Jotaro Part 4")
                Fluent:Notify({Title = "Info", Content = "Teleporting to Alternate Jotaro Part 4 spawn point.", Duration = 3})
            end
            task.wait(1)
        end
    end)
end

_G.Tabs.BossFarm:AddDropdown("SelectBosses", {Title = "Select Bosses", Values = bossList, Multi = true, Default = {}})
Options.SelectBosses:OnChanged(function(Value)
    _G.selectedBosses = {}
    for boss, enabled in pairs(Value) do
        if enabled then
            table.insert(_G.selectedBosses, boss)
        end
    end
end)

_G.Tabs.BossFarm:AddToggle("AutoFarmBoss", {Title = "Auto Farm Boss", Description = "Toggle boss farming (waits for bosses to spawn)", Default = false})
Options.AutoFarmBoss:OnChanged(function()
    _G.isBossFarming = Options.AutoFarmBoss.Value
    if _G.isBossFarming then
        if #_G.selectedBosses == 0 then
            Fluent:Notify({Title = "Error", Content = "Please select at least one boss first!", Duration = 5})
            _G.isBossFarming = false
            Options.AutoFarmBoss:SetValue(false)
            return
        end
        Fluent:Notify({Title = "Info", Content = "Boss Farm enabled! Waiting for bosses to spawn...", Duration = 3})
        task.spawn(_G.startBossFarming)
    else
        if bodyPosition then bodyPosition:Destroy() bodyPosition = nil end
        if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
        local char = _G.waitForCharacter()
        if char then char.Humanoid.Sit = false end
        Fluent:Notify({Title = "Info", Content = "Boss Farm disabled!", Duration = 3})
    end
end)

-- Tab: Stand Farm
do
    local StandArrowsList = {
        "Cream", "HierophantGreen", "KillerQueen", "SilverChariot", "StarPlatinum", "StickyFingers",
        "StarPlatinum:StoneOcean", "CrazyDiamond", "Aerosmith", "StoneFree", "TheEmperor", "TheHand",
        "softandwet", "magiciansred", "DiverDown", "PurpleSmoke", "WhiteSnake", "TheWorld", "WeatherReport",
        "D4C", "DirtyDeedsDoneDirtCheap", "GoldenExperience", "KingCrimson", "PremierMacho",
        "SilverChariotOVA", "TheWorldOVA", "Jotaro'sStarPlatinum", "StarPlatinum OVA"
    }

    local ChargedArrowsList = {
        "CrazyDiamond", "SilverChariot", "HierophantGreen", "KillerQueen", "StarPlatinum", "TheHand",
        "D4she", "DirtyDeedsDoneDirtCheap", "GoldenExperience", "KingCrimson", "TheWorld", "TuskAct1",
        "TheWorld:AlternativeUniverse", "Whitesnake", "Dio'sThe World"
    }

    local AttributesList = {
        "None", "Strong", "Tough", "Sloppy", "Powerful", "Manic", "Enrage", "Lethargic", "Godly",
        "Daemon", "Invincible", "Tragic", "Scourge", "GlassCannon", "Hacker", "Legendary"
    }

    _G.WhitelistedStands = {}
    _G.WhitelistedAttributes = {}
    _G.ArrowToUse = "Stand Arrow"
    _G.CheckStand, _G.CheckAttri = false, false
    local MarketplaceService = game:GetService("MarketplaceService")
    local gamepassId1 = 123456
    local gamepassId2 = 789012

    _G.normalizeString = function(str)
        return str:gsub("[%s:']", ""):upper()
    end

    _G.notify = function(title, content, duration)
        Fluent:Notify({Title = title, Content = content, Duration = duration or 5})
    end

    _G.checkGamepass = function()
        local hasGamepass = false
        pcall(function()
            if MarketplaceService:UserOwnsGamePassAsync(LocalPlayer.UserId, gamepassId1) or 
               MarketplaceService:UserOwnsGamePassAsync(LocalPlayer.UserId, gamepassId2) then
                hasGamepass = true
            end
        end)
        return hasGamepass
    end

    _G.useItem = function(itemName, char)
        local itemInBackpack = LocalPlayer.Backpack:FindFirstChild(itemName)
        local itemInHand = char:FindFirstChild(itemName)
        
        if itemInHand then
            char.Humanoid:UnequipTools()
            task.wait(0.1)
        end
        
        if not itemInBackpack then
            return false
        end
        
        char.Humanoid:EquipTool(itemInBackpack)
        task.wait(0.1)
        if char:FindFirstChild(itemName) then
            char[itemName]:Activate()
            _G.fireServerSafe(ReplicatedStorage.Events.UseItem)
            local prompt = char[itemName]:FindFirstChildOfClass("ProximityPrompt")
            if prompt then fireproximityprompt(prompt, 1) end
            task.wait(0.5)
            return true
        end
        return false
    end

    _G.checkStandAndAttribute = function()
        local stand = LocalPlayer.Data and LocalPlayer.Data.Stand and LocalPlayer.Data.Stand.Value or "None"
        local attribute = LocalPlayer.Data and LocalPlayer.Data.Attri and LocalPlayer.Data.Attri.Value or "None"
        stand = _G.normalizeString(stand)
        attribute = tostring(attribute)

        local standMatch = not _G.CheckStand or (_G.CheckStand and table.find(_G.WhitelistedStands, stand))
        local attriMatch = not _G.CheckAttri or (_G.CheckAttri and table.find(_G.WhitelistedAttributes, attribute))
        return standMatch and attriMatch
    end

    _G.resetCharacterState = function()
        local char = _G.waitForCharacter()
        if char then
            char.Humanoid:UnequipTools()
            if bodyPosition then bodyPosition:Destroy() bodyPosition = nil end
            if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
            char.Humanoid.Sit = false
        end
    end

    _G.cycleStand = function()
        local char = _G.waitForCharacter()
        if not char then
            return false, "no_character"
        end

        local stand = LocalPlayer.Data and LocalPlayer.Data.Stand and LocalPlayer.Data.Stand.Value or "None"
        stand = _G.normalizeString(stand)

        if _G.checkStandAndAttribute() then
            local stored = false
            local level = LocalPlayer.Data and LocalPlayer.Data.Level and LocalPlayer.Data.Level.Value or 1
            local hasGamepass = _G.checkGamepass()
            local slotsToCheck = {1, 2}
            if hasGamepass then
                table.insert(slotsToCheck, 3)
                table.insert(slotsToCheck, 6)
            end
            if level >= 120 then
                table.insert(slotsToCheck, 5)
            end

            for _, i in ipairs(slotsToCheck) do
                if i ~= 4 then
                    if LocalPlayer.Data and LocalPlayer.Data["Slot" .. i .. "Stand"] and LocalPlayer.Data["Slot" .. i .. "Stand"].Value == "None" then
                        _G.fireServerSafe(ReplicatedStorage.Events.SwitchStand, "Slot" .. i)
                        local timeout = tick() + 5
                        while tick() < timeout and LocalPlayer.Data and LocalPlayer.Data.Stand and LocalPlayer.Data.Stand.Value ~= "None" and _G.BeginFarm do
                            task.wait(0.1)
                        end
                        if LocalPlayer.Data and LocalPlayer.Data.Stand and LocalPlayer.Data.Stand.Value == "None" then
                            stored = true
                            _G.notify("Success", "Stand stored in Slot " .. i, 3)
                        end
                        break
                    end
                end
            end
            if stored then
                return true, "stored"
            else
                return false, "no_slots"
            end
        elseif stand == "NONE" then
            if not _G.useItem(_G.ArrowToUse, char) then
                return false, "no_arrow"
            end
            local timeout = tick() + 5
            while tick() < timeout and LocalPlayer.Data and LocalPlayer.Data.Stand and LocalPlayer.Data.Stand.Value == "None" and _G.BeginFarm do
                task.wait(0.1)
            end
            return true, "used_arrow"
        else
            if not _G.useItem("Rokakaka", char) then
                return false, "no_rokakaka"
            end
            local timeout = tick() + 5
            while tick() < timeout and LocalPlayer.Data and LocalPlayer.Data.Stand and LocalPlayer.Data.Stand.Value ~= "None" and _G.BeginFarm do
                task.wait(0.1)
            end
            return true, "used_rokakaka"
        end
    end

    _G.Tabs.StandFarm:AddDropdown("SelectStands", {
        Title = "Select Stands",
        Description = "Choose stands to farm",
        Values = StandArrowsList,
        Multi = true,
        Default = {}
    })
    Options.SelectStands:OnChanged(function(Value)
        _G.WhitelistedStands = {}
        for stand, state in pairs(Value) do
            if state then
                table.insert(_G.WhitelistedStands, _G.normalizeString(stand))
            end
        end
    end)

    _G.Tabs.StandFarm:AddDropdown("SelectAttributes", {
        Title = "Select Attributes",
        Description = "Choose attributes to farm",
        Values = AttributesList,
        Multi = true,
        Default = {}
    })
    Options.SelectAttributes:OnChanged(function(Value)
        _G.WhitelistedAttributes = {}
        for attr, state in pairs(Value) do
            if state then
                table.insert(_G.WhitelistedAttributes, attr)
            end
        end
    end)

    _G.Tabs.StandFarm:AddButton({Title = "Use Stand Arrows", Callback = function() _G.ArrowToUse = "Stand Arrow" end})
    _G.Tabs.StandFarm:AddButton({Title = "Use Charged Arrows", Callback = function() _G.ArrowToUse = "Charged Arrow" end})

    _G.Tabs.StandFarm:AddToggle("StandCheck", {Title = "Stand Check", Default = false})
    Options.StandCheck:OnChanged(function() _G.CheckStand = Options.StandCheck.Value end)

    _G.Tabs.StandFarm:AddToggle("AttributeCheck", {Title = "Attribute Check", Default = false})
    Options.AttributeCheck:OnChanged(function() _G.CheckAttri = Options.AttributeCheck.Value end)

    _G.Tabs.StandFarm:AddButton({Title = "Open Stand Storage", Callback = function() 
        _G.fireServerSafe(Workspace.Map.NPCs.admpn.Done) 
    end})

    _G.Tabs.StandFarm:AddButton({Title = "Reset Character", Callback = function()
        _G.resetCharacterState()
        _G.notify("Info", "Character state reset!", 3)
    end})

    _G.Tabs.StandFarm:AddToggle("StartStandFarm", {Title = "Start Stand Farm", Default = false})
    Options.StartStandFarm:OnChanged(function()
        _G.BeginFarm = Options.StartStandFarm.Value
        if _G.BeginFarm then
            if not _G.CheckStand and not _G.CheckAttri then
                _G.notify("Error", "Enable Stand Check or Attribute Check first!", 5)
                _G.BeginFarm = false
                Options.StartStandFarm:SetValue(false)
                return
            end
            if _G.CheckStand and #_G.WhitelistedStands == 0 then
                _G.notify("Error", "Select at least one Stand!", 5)
                _G.BeginFarm = false
                Options.StartStandFarm:SetValue(false)
                return
            end
            if _G.CheckAttri and #_G.WhitelistedAttributes == 0 then
                _G.notify("Error", "Select at least one Attribute!", 5)
                _G.BeginFarm = false
                Options.StartStandFarm:SetValue(false)
                return
            end
            _G.notify("Info", "Stand Farm Started", 3)
            _G.resetCharacterState()
            task.spawn(function()
                LocalPlayer.CharacterAdded:Connect(function()
                    if _G.BeginFarm then
                        _G.notify("Info", "Character respawned, resuming Stand Farm...", 3)
                        _G.resetCharacterState()
                    end
                end)
                while _G.BeginFarm do
                    if _G.isItemFarming then
                        _G.notify("Warning", "Item Farm is active, waiting to resume Stand Farm...", 5)
                        while _G.isItemFarming and _G.BeginFarm do
                            task.wait(1)
                        end
                        if not _G.BeginFarm then break end
                        _G.notify("Info", "Resuming Stand Farm after Item Farm stopped", 3)
                    end
                    
                    local success, reason = _G.cycleStand()
                    if success and reason == "stored" then
                        _G.notify("Info", "Desired Stand found and stored! Stopping farm...", 5)
                        _G.BeginFarm = false
                        Options.StartStandFarm:SetValue(false)
                        break
                    elseif not success then
                        if reason == "no_character" then
                            _G.notify("Warning", "Character not found, waiting for respawn...", 5)
                            while not LocalPlayer.Character and _G.BeginFarm do
                                task.wait(1)
                            end
                        elseif reason == "no_arrow" then
                            _G.notify("Warning", "Out of " .. _G.ArrowToUse .. ", waiting for more...", 5)
                            while not LocalPlayer.Backpack:FindFirstChild(_G.ArrowToUse) and _G.BeginFarm do
                                task.wait(1)
                            end
                        elseif reason == "no_rokakaka" then
                            _G.notify("Warning", "Out of Rokakaka, waiting for more...", 5)
                            while not LocalPlayer.Backpack:FindFirstChild("Rokakaka") and _G.BeginFarm do
                                task.wait(1)
                            end
                        elseif reason == "no_slots" then
                            _G.notify("Warning", "No empty slots available! Stopping farm...", 5)
                            _G.BeginFarm = false
                            Options.StartStandFarm:SetValue(false)
                            break
                        else
                            _G.notify("Warning", "Unknown issue, retrying...", 5)
                            _G.resetCharacterState()
                        end
                    end
                    task.wait(0.1)
                end
                _G.resetCharacterState()
                _G.notify("Info", "Stand Farm Stopped", 3)
            end)
        else
            _G.notify("Info", "Stand Farm Stopped", 3)
        end
    end)
end

-- Tab: Auto Buy Item
_G.Amount = 1

_G.Tabs.AutoBuy:AddButton({Title = "Teleport to Shop", Callback = function()
    local char = _G.waitForCharacter()
    if char then
        _G.Teleport(char.HumanoidRootPart, CFrame.new(11927.1, -3.28935, -4488.59))
        if char:FindFirstChild("Stand") then
            _G.Teleport(char.Stand.HumanoidRootPart, char.HumanoidRootPart.CFrame)
        end
    end
end})

_G.Tabs.AutoBuy:AddInput("BuyAmount", {Title = "Enter Amount", Default = "1", Numeric = true, Callback = function(Value) _G.Amount = tonumber(Value) or 1 end})

local buyItems = {
    {"Rokakaka (2,500c)", "MerchantAU", "Option2"},
    {"Stand Arrow (3,500c)", "MerchantAU", "Option4"},
    {"Charged Arrow (50,000c)", "Merchantlvl120", "Option2"},
    {"Dio Diary (1,500,000c)", "Merchantlvl120", "Option3"},
    {"Requiem Arrow (1,500,000c)", "Merchantlvl120", "Option4"}
}
for _, item in ipairs(buyItems) do
    _G.Tabs.AutoBuy:AddButton({Title = item[1], Callback = function()
        for i = 1, _G.Amount do
            ReplicatedStorage.Events.BuyItem:FireServer(item[2], item[3])
        end
    end})
end

-- Tab: Dungeon Farm
local DunLvl = {
    "Dungeon [Lvl.15+]", "Dungeon [Lvl.40+]", "Dungeon [Lvl.80+]", "Dungeon [Lvl.100+]", "Dungeon [Lvl.200+]"
}
local dungeonSettings = {
    ["Dungeon [Lvl.15+]"] = {npcMonster = "i_stabman [Lvl. 15+]", bossName = "Bad Gi Boss", baseDistance = 7},
    ["Dungeon [Lvl.40+]"] = {npcMonster = "i_stabman [Lvl. 40+]", bossName = "Dio [Dungeon]", baseDistance = 10},
    ["Dungeon [Lvl.80+]"] = {npcMonster = "i_stabman [Lvl. 80+]", bossName = "Homeless Lord", baseDistance = 12},
    ["Dungeon [Lvl.100+]"] = {npcMonster = "i_stabman [Lvl. 100+]", bossName = "Diavolo [Dungeon]", baseDistance = 10},
    ["Dungeon [Lvl.200+]"] = {npcMonster = "i_stabman [Lvl. 200+]", bossName = "Jotaro P6 [Dungeon]", baseDistance = 15}
}

_G.ChDun = "Dungeon [Lvl.15+]"
_G.isDungeonFarming = false
local dungeonConnection
_G.lastTeleport = 0
local currentTarget = nil
local safePosition = nil
_G.currentDistance = 7
_G.minDistance = 3
_G.maxDistance = 20
_G.lastHealth = 0
_G.lastDamageCheck = 0

_G.isQuestActive = function()
    local questGui = LocalPlayer.PlayerGui:FindFirstChild("QuestGui")
    return questGui and questGui:FindFirstChild("Active") and questGui.Active.Value or false
end

_G.findDungeonNPC = function()
    for _, npc in ipairs(Workspace.Map.NPCs:GetChildren()) do
        if npc.Name:find("i_stabman") and npc:FindFirstChild("Head") and npc.Head:FindFirstChild("Main") and npc.Head.Main:FindFirstChild("Text") then
            if npc.Head.Main.Text.Text == dungeonSettings[_G.ChDun].npcMonster then
                local npcHRP = npc:FindFirstChild("HumanoidRootPart")
                if npcHRP then
                    safePosition = npcHRP.CFrame + Vector3.new(0, 3, 5)
                    return npc
                end
            end
        end
    end
    return nil
end

_G.findDungeonBoss = function()
    for _, boss in pairs(Workspace.Living:GetChildren()) do
        if boss.Name == "Boss" and boss:FindFirstChild("Humanoid") and boss.Humanoid.Health > 0 then
            local head = boss:FindFirstChild("Head")
            if head and head:FindFirstChild("Display") and head.Display:FindFirstChild("Frame") then
                local text = head.Display.Frame:FindFirstChild("TextLabel") or head.Display.Frame:FindFirstChild("t")
                if text and text.Text == dungeonSettings[_G.ChDun].bossName then
                    return boss
                end
            end
        end
    end
    return nil
end

_G.updatePositionToTarget = function(target)
    local char = _G.waitForCharacter()
    if not char or not target or not target:FindFirstChild("HumanoidRootPart") then return end
    
    local hrp = char.HumanoidRootPart
    local targetHRP = target.HumanoidRootPart
    local stand = char:FindFirstChild("Stand")
    local standHRP = stand and stand:FindFirstChild("HumanoidRootPart")

    local targetPos = targetHRP.Position
    local direction = (targetPos - hrp.Position).Unit
    local adjustedPos = targetPos - (direction * _G.currentDistance) + Vector3.new(0, _G.Disc, _G.Disc3)
    local targetCFrame = CFrame.lookAt(adjustedPos, targetPos)

    _G.createBodyControls(hrp)
    bodyPosition.Position = adjustedPos
    bodyGyro.CFrame = targetCFrame

    if (hrp.Position - adjustedPos).Magnitude > 5 then
        _G.Teleport(hrp, targetCFrame)
        if standHRP then _G.Teleport(standHRP, targetCFrame) end
    end
end

_G.adjustDistanceIfNoDamage = function(boss)
    if not boss or not boss:FindFirstChild("Humanoid") then return end
    local now = tick()
    
    if now - _G.lastDamageCheck >= 2 then
        local currentHealth = boss.Humanoid.Health
        if currentHealth >= _G.lastHealth and _G.lastHealth > 0 then
            if _G.currentDistance > _G.minDistance then
                _G.currentDistance = math.max(_G.minDistance, _G.currentDistance - 2)
            end
        end
        _G.lastHealth = currentHealth
        _G.lastDamageCheck = now
    end
end

_G.Tabs.DungeonFarm:AddDropdown("ChooseDungeon", {Title = "Choose Dungeon", Values = DunLvl, Default = 1})
Options.ChooseDungeon:OnChanged(function()
    _G.ChDun = Options.ChooseDungeon.Value
    _G.currentDistance = dungeonSettings[_G.ChDun].baseDistance
    currentTarget = nil
    safePosition = nil
    _G.lastHealth = 0
    _G.lastDamageCheck = 0
end)

_G.Tabs.DungeonFarm:AddToggle("AutoFarmDungeon", {Title = "Auto Farm Dungeon", Default = false})
Options.AutoFarmDungeon:OnChanged(function()
    _G.isDungeonFarming = Options.AutoFarmDungeon.Value
    if _G.isFarming or _G.isLevelFarming or _G.isBossFarming then
        Fluent:Notify({Title = "Error", Content = "Please disable other farming modes first!", Duration = 5})
        _G.isDungeonFarming = false
        Options.AutoFarmDungeon:SetValue(false)
        return
    end
    if not _G.ChDun or not dungeonSettings[_G.ChDun] then
        Fluent:Notify({Title = "Error", Content = "No valid dungeon selected!", Duration = 5})
        _G.isDungeonFarming = false
        Options.AutoFarmDungeon:SetValue(false)
        return
    end

    if _G.isDungeonFarming then
        _G.currentDistance = dungeonSettings[_G.ChDun].baseDistance
        Fluent:Notify({Title = "Info", Content = "Dungeon Farm Started", Duration = 3})
        task.spawn(function()
            dungeonConnection = RunService.Heartbeat:Connect(function()
                if not _G.isDungeonFarming then
                    if dungeonConnection then dungeonConnection:Disconnect() end
                    if bodyPosition then bodyPosition:Destroy() bodyPosition = nil end
                    if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
                    local char = _G.waitForCharacter()
                    if char then char.Humanoid.Sit = false end
                    Fluent:Notify({Title = "Info", Content = "Dungeon Farm Stopped", Duration = 3})
                    return
                end

                local char = _G.waitForCharacter()
                if not char or not char:FindFirstChild("HumanoidRootPart") then
                    task.wait(1)
                    return
                end
                local hrp = char.HumanoidRootPart
                local now = tick()

                if not _G.isQuestActive() and (not currentTarget or currentTarget == "NPC") then
                    local npc = _G.findDungeonNPC()
                    if npc and now - _G.lastTeleport > 1 then
                        local npcHRP = npc:FindFirstChild("HumanoidRootPart")
                        if npcHRP then
                            _G.Teleport(hrp, npcHRP.CFrame + Vector3.new(0, 2, 2))
                            _G.lastTeleport = now
                            local prompt = npcHRP:FindFirstChildOfClass("ProximityPrompt")
                            if prompt then fireproximityprompt(prompt, 20) end
                            local done = npc:FindFirstChild("Done")
                            if done then _G.fireServerSafe(done) end
                            currentTarget = "Boss"
                            task.wait(5)
                        end
                    end
                end

                if currentTarget == "Boss" then
                    local boss = _G.findDungeonBoss()
                    if boss then
                        _G.updatePositionToTarget(boss)
                        _G.adjustDistanceIfNoDamage(boss)
                        if char:FindFirstChild("Aura") and not char.Aura.Value then
                            _G.fireServerSafe(char.StandEvents.Summon)
                        end
                        if char:FindFirstChild("StandEvents") and not LocalPlayer.PlayerGui.CDgui.fortnite:FindFirstChild("Punch") then
                            _G.fireServerSafe(char.StandEvents.M1)
                        end
                        local selectedSkills = Options.SelectedSkills and Options.SelectedSkills.Value or {}
                        if next(selectedSkills) then
                            _G.useSelectedSkills(char, selectedSkills)
                        elseif _G.isUsingAllSkills then
                            _G.useAllSkills(char)
                        end
                    else
                        if now - _G.lastTeleport > 5 then
                            if safePosition then
                                _G.Teleport(hrp, safePosition)
                                _G.lastTeleport = now
                                local npc = _G.findDungeonNPC()
                                if npc then
                                    local questDone = npc:FindFirstChild("QuestDone")
                                    if questDone then _G.fireServerSafe(questDone) end
                                end
                                currentTarget = "NPC"
                            end
                        end
                    end
                end
                task.wait(0.1)
            end)
        end)
    end
end)

_G.Tabs.DungeonFarm:AddSlider("DungeonYOffset", {Title = "Y Offset", Description = "Adjust hover height", Default = 7, Min = -30, Max = 30, Rounding = 1})
Options.DungeonYOffset:OnChanged(function(Value)
    _G.Disc = Value
end)

_G.Tabs.DungeonFarm:AddSlider("DungeonZOffset", {Title = "Z Offset", Description = "Adjust forward/backward distance", Default = 0, Min = -30, Max = 30, Rounding = 1})
Options.DungeonZOffset:OnChanged(function(Value)
    _G.Disc3 = Value
end)

_G.Tabs.DungeonFarm:AddButton({Title = "Refresh Character", Callback = function()
    local char = _G.waitForCharacter()
    if char then
        if bodyPosition then bodyPosition:Destroy() bodyPosition = nil end
        if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
        char.Humanoid.Sit = false
    end
end})

-- Tab: Item Farm
_G.isItemFarming = false
local itemConnection

_G.safeTeleport = function(part, cframe)
    if part and part:IsA("BasePart") then
        pcall(function()
            part.CFrame = cframe
            part.Velocity = Vector3.new(0, 0, 0)
        end)
    end
end

_G.Tabs.ItemFarm:AddToggle("FarmItems", {Title = "Farm Items", Description = "Collect nearby items", Default = false})
Options.FarmItems:OnChanged(function()
    _G.isItemFarming = Options.FarmItems.Value
    _G.On = _G.isItemFarming

    if _G.isItemFarming and (_G.isFarming or _G.isLevelFarming or _G.isBossFarming or _G.isDungeonFarming) then
        _G.isItemFarming = false
        _G.On = false
        Options.FarmItems:SetValue(false)
        return
    end

    if itemConnection then
        itemConnection:Disconnect()
    end

    if _G.isItemFarming then
        itemConnection = RunService.Heartbeat:Connect(function()
            if not _G.isItemFarming or not _G.On then
                if itemConnection then itemConnection:Disconnect() end
                local char = _G.waitForCharacter()
                if char then char.Humanoid.Sit = false end
                return
            end

            local char = _G.waitForCharacter()
            if not char or not char:FindFirstChild("HumanoidRootPart") then
                task.wait(1)
                return
            end
            local hrp = char.HumanoidRootPart

            for _, v in pairs(Workspace.Vfx:GetDescendants()) do
                if v:IsA("BasePart") and (v.Name == "Handle" or v.Name:find("Item")) and v.Parent then
                    local prompt = v.Parent:FindFirstChild("ProximityPrompt") or v:FindFirstChild("ProximityPrompt")
                    if prompt then
                        local distance = (hrp.Position - v.Position).Magnitude
                        if distance > 5 then
                            _G.safeTeleport(hrp, CFrame.new(v.Position + Vector3.new(0, 3, 0)))
                            task.wait(0.5)
                        end
                        if distance <= 5 then
                            fireproximityprompt(prompt, 20)
                            task.wait(0.3)
                        end
                    end
                end
            end

            if Workspace:FindFirstChild("Items") then
                for _, item in pairs(Workspace.Items:GetChildren()) do
                    if item:IsA("BasePart") and item:FindFirstChild("ProximityPrompt") then
                        local distance = (hrp.Position - item.Position).Magnitude
                        if distance > 5 then
                            _G.safeTeleport(hrp, CFrame.new(item.Position + Vector3.new(0, 3, 0)))
                            task.wait(0.5)
                        end
                        if distance <= 5 then
                            fireproximityprompt(item.ProximityPrompt, 20)
                            task.wait(0.3)
                        end
                    end
                end
            end

            task.wait(0.5)
        end)
    else
        if itemConnection then itemConnection:Disconnect() end
        local char = _G.waitForCharacter()
        if char then char.Humanoid.Sit = false end
    end
end)

-- Tab: Settings
_G.isAntiAFK = false

_G.antiAFK = function()
    task.spawn(function()
        while _G.isAntiAFK do
            local char = _G.waitForCharacter()
            if char then
                game:GetService("VirtualInputManager"):SendKeyEvent(true, "W", false, game)
                task.wait(0.1)
                game:GetService("VirtualInputManager"):SendKeyEvent(false, "W", false, game)
                task.wait(300)
            else
                task.wait(5)
            end
        end
    end)
end

_G.Tabs.Settings:AddToggle("AntiAFK", {Title = "Anti-AFK", Description = "Prevent AFK kick", Default = false})
Options.AntiAFK:OnChanged(function()
    _G.isAntiAFK = Options.AntiAFK.Value
    if _G.isAntiAFK then _G.antiAFK() end
end)

_G.Tabs.Settings:AddToggle("UseAllSkills", {Title = "Use All Skills", Description = "Toggle using all skills during farming", Default = false})
Options.UseAllSkills:OnChanged(function()
    _G.isUsingAllSkills = Options.UseAllSkills.Value
end)

_G.Tabs.Settings:AddDropdown("SelectedSkills", {
    Title = "Select Skills",
    Description = "Choose multiple skills to use during farming",
    Values = _G.getPlayerSkills(),
    Multi = true,
    Default = {}
})

LocalPlayer.CharacterAdded:Connect(function()
    if _G.Tabs.Settings then
        Options.SelectedSkills:SetValues(_G.getPlayerSkills())
    end
end)

local VirtualInputManager = game:GetService("VirtualInputManager")
local UserInputService = game:GetService("UserInputService")

local availableKeys = {
    "E", "R", "T", "Y", "J", "H", "F", "Z", "X", "C", "V",
    "LeftClick", "RightClick"
}

_G.Asd = false
_G.selectedKeys = {}
_G.toggleKey = Enum.KeyCode.P

_G.pressKey = function(key)
    if key == "E" then
        VirtualInputManager:SendKeyEvent(true, "E", false, game)
        task.wait(4)
        VirtualInputManager:SendKeyEvent(false, "E", false, game)
    elseif key == "LeftClick" then
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
        task.wait(0.05)
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
    elseif key == "RightClick" then
        VirtualInputManager:SendMouseButtonEvent(0, 0, 1, true, game, 0)
        task.wait(0.05)
        VirtualInputManager:SendMouseButtonEvent(0, 0, 1, false, game, 0)
    else
        VirtualInputManager:SendKeyEvent(true, key, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, key, false, game)
    end
end

_G.useSelectedKeys = function()
    task.spawn(function()
        while _G.Asd do
            local char = _G.waitForCharacter()
            if not char then
                task.wait(1)
                continue
            end
            for key, enabled in pairs(_G.selectedKeys) do
                if enabled then
                    _G.pressKey(key)
                    if key == "E" then
                        task.wait(0.5)
                    elseif key == "LeftClick" or key == "RightClick" then
                        task.wait(0.0)
                    else
                        task.wait(0.2)
                    end
                end
            end
            task.wait(0.5)
        end
    end)
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == _G.toggleKey then
        _G.Asd = not _G.Asd
        if _G.Asd then
            if next(_G.selectedKeys) == nil then
                Fluent:Notify({Title = "Error", Content = "Please select at least one key first!", Duration = 5})
                _G.Asd = false
                Options.UseKeySkills:SetValue(false)
                return
            end
            Fluent:Notify({Title = "Info", Content = "Key Skills activated with '" .. _G.toggleKey.Name .. "'!", Duration = 3})
            _G.useSelectedKeys()
            Options.UseKeySkills:SetValue(true)
        else
            Fluent:Notify({Title = "Info", Content = "Key Skills stopped with '" .. _G.toggleKey.Name .. "'!", Duration = 3})
            Options.UseKeySkills:SetValue(false)
        end
    end
end)

_G.Tabs.Settings:AddDropdown("SelectKeySkills", {
    Title = "Select Key Skills",
    Description = "Choose multiple keys to use as skills (E holds 4s, Left/Right rapid)",
    Values = availableKeys,
    Multi = true,
    Default = {}
})
Options.SelectKeySkills:OnChanged(function(Value)
    _G.selectedKeys = {}
    for key, state in pairs(Value) do
        if state then
            _G.selectedKeys[key] = true
        end
    end
end)

_G.Tabs.Settings:AddToggle("UseKeySkills", {
    Title = "Use Key Skills",
    Description = "Toggle to use selected key skills (or press '" .. _G.toggleKey.Name .. "')",
    Default = false
})
Options.UseKeySkills:OnChanged(function()
    _G.Asd = Options.UseKeySkills.Value
    if _G.Asd then
        if next(_G.selectedKeys) == nil then
            Fluent:Notify({Title = "Error", Content = "Please select at least one key first!", Duration = 5})
            _G.Asd = false
            Options.UseKeySkills:SetValue(false)
            return
        end
        Fluent:Notify({Title = "Info", Content = "Key Skills activated via GUI!", Duration = 3})
        _G.useSelectedKeys()
    else
        Fluent:Notify({Title = "Info", Content = "Key Skills stopped via GUI!", Duration = 3})
    end
end)

_G.Window:SelectTab(1)
Fluent:Notify({Title = "EDU HUB", Content = "The script has been loaded.", Duration = 8})
SaveManager:LoadAutoloadConfig()

-- Floating Button
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.Name = "FloatingButtonGui"
ScreenGui.ResetOnSpawn = false

local FloatingButton = Instance.new("ImageButton")
FloatingButton.Size = UDim2.new(0, 50, 0, 50)
FloatingButton.Position = UDim2.new(0.5, -25, 0.5, -25)
FloatingButton.BackgroundTransparency = 1
FloatingButton.Image = "http://www.roblox.com/asset/?id=12514663645"
FloatingButton.Parent = ScreenGui

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1, 0)
UICorner.Parent = FloatingButton

local dragging
local dragInput
local dragStart
local startPos

FloatingButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = FloatingButton.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

FloatingButton.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and (input == dragInput) then
        local delta = input.Position - dragStart
        FloatingButton.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
    end
end)

local isUIVisible = true
_G.Window.MinimizeKey = Enum.KeyCode.RightControl

FloatingButton.MouseButton1Click:Connect(function()
    isUIVisible = not isUIVisible
    if isUIVisible then
        _G.Window:Minimize(false)
        TweenService:Create(FloatingButton, TweenInfo.new(0.3), {ImageTransparency = 0}):Play()
    else
        _G.Window:Minimize(true)
        TweenService:Create(FloatingButton, TweenInfo.new(0.3), {ImageTransparency = 0.5}):Play()
    end
end)

_G.Window:Minimize(false)
